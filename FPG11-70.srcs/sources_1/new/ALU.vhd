----------------------------------------------------------------------------------
-- Company: 
-- Engineer: Matt Burton
-- 
-- Create Date: 10/22/2018 08:59:57 PM
-- Design Name: 
-- Module Name: ALU - Behavioral
-- Project Name: FPG-11/70
-- Target Devices: Artix-7
-- Tool Versions: Vivado 2018.2
-- Description: Implementation of a 16-bit 74S181 (ALU). This means that internal
--              signals, and signals generated by the 74S182 carry lookahead generator
--              are abstracted in this design. Therefore the only the following signals
--              need to be generated and output:
--                  -DAPH ALU 15:00 H   =   FUNCTION OUT
--                  -DAPF A=B (7:0) H   =   LOW BYTE COMPARATOR
--                  -DAPF A=B (15:00) H =   COMPARATOR
--                  -DAPH COUT 15 H     =   CARRY OUT
--              The following data are input into the ALU:
--                  -DAPB/C/D AMX 15:00 H   =   INPUT FROM AMX MUX
--                  -DAPB/C/D BMX 15:00 H   =   INPUT FROM BMX MUX
--              The following control signals are input into the ALU
--                  -GRAA ALUC C H  =   Carry input
--                  -DAPH LM H and DAPF HM H    =   MODE
--                      -These signals are generated by GRAA ALUM L
--                  -DAPF LS3:0 H and DAPH HS3:0 H  = SELECTION
--                      -These signals are generated by GRAA ALUS3:0 L
-- Dependencies: 
-- 
-- Revision:
-- Revision 0.01 - File Created
-- Additional Comments:
--      EK-KB11C-TM-001 Section II Chapter 2.1.1
--      Engineering Drawings DAPF, DAPH
----------------------------------------------------------------------------------


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;                 

-- Uncomment the following library declaration if using
-- arithmetic functions with Signed or Unsigned values
use IEEE.NUMERIC_STD.ALL;

-- Uncomment the following library declaration if instantiating
-- any Xilinx leaf cells in this code.
--library UNISIM;
--use UNISIM.VComponents.all;

entity ALU is
    Port ( AMX : in STD_LOGIC_VECTOR (15 downto 0); --INPUT MUX
           BMX : in STD_LOGIC_VECTOR (15 downto 0); --INPUT MUX
           S : in STD_LOGIC_VECTOR (3 downto 0);    --SELECTION
           M : in STD_LOGIC;                        --MODE
           CIN : in STD_LOGIC;                      --CARRY-IN
           F : out STD_LOGIC_VECTOR (15 downto 0);  --FUNCTION OUT
           A_B_L : out STD_LOGIC;                     --LOW BYTE COMPARATOR
           A_B  :   out STD_LOGIC;                    --FULL COMPARATOR
--           P : out STD_LOGIC;                       --Propogate
--           G : out STD_LOGIC;                       --Generate
           COUT : out STD_LOGIC);                   --CARRY-OUT
end ALU;

architecture Behavioral of ALU is
    --INTERNAL SIGNALS CORRESPOND TO SIGNALS ON ENGINEERING DRAWINGS
    signal DAPH_ALU_H : STD_LOGIC_VECTOR (15 downto 0); --DAPH ALU 15:00 H
    signal CARRY_TEMP : STD_LOGIC_VECTOR (16 downto 0); 
begin

    process (AMX, BMX)
    begin
    
        --GENERATE ADDITION FUNCTION TO POPULATE CARRY_TEMP(16)
        CARRY_TEMP <= '0' & AMX + BMX;
        --GENERATE FUNCTION OUT SIGNAL
        if M = '1' then --LOGIC mode
        
            case S is
                when "0000" =>
                    DAPH_ALU_H <= NOT(AMX);         --F=!A
                when "0011" =>
                    DAPH_ALU_H <= (others => '0');  --F=0
                when "0110" =>
                    DAPH_ALU_H <= (AMX XOR BMX);    --F=A XOR B
                when "0111" =>
                    DAPH_ALU_H <= (AMX AND NOT(BMX));--F=A!B
                when "1001" =>
                    DAPH_ALU_H <= (AMX XNOR BMX);    --F=!(A XOR B)
                when "1010" =>
                    DAPH_ALU_H <= BMX;               --F=B
                when "1011" =>
                    DAPH_ALU_H <= AMX AND BMX;       --F=AB
                when "1100" =>
                    DAPH_ALU_H <= (others => '1');   --F=1
                when "1110" =>
                    DAPH_ALU_H <= AMX OR BMX;        --F=A OR B
                when "1111" =>
                    DAPH_ALU_H <= AMX;               --F=A
                when others =>
                    DAPH_ALU_H <= (others => 'X');   --undefined
            end case;
        
        else            --ARITHMETIC
        
            if CIN = '0' then   --NO CARRY
            
                case S is                   
                    when "0000" =>
                        DAPH_ALU_H <= AMX;              --F=A
                    when "0011" =>
                        DAPH_ALU_H <= (others => '1');  --F= - 1 (2's complement)
                    when "0110" =>
                        DAPH_ALU_H <= AMX - BMX - '1';  --F = A - B - 1
                    when "0111" =>
                        DAPH_ALU_H <= (AMX AND NOT BMX) - '1';--F=A!B - 1
                    when "1001" =>
                        DAPH_ALU_H <= AMX + BMX;        --F= A + B
                    when "1010" =>
                        DAPH_ALU_H <= (AMX + NOT BMX) + (AMX AND BMX);  --(A+!B) + AB
                    when "1011" =>
                        DAPH_ALU_H <= (AMX AND BMX) - '1'; --F= AB -1
                    when "1100" =>
                        DAPH_ALU_H <= AMX + AMX;          --F= A+A
                    when "1110" =>
                        DAPH_ALU_H <= (AMX + NOT BMX) + AMX; --F= (A+!B) + A
                    when "1111" =>
                        DAPH_ALU_H <= AMX - '1';          --F= (A - 1)
                    when others =>
                        DAPH_ALU_H <= (others => 'X');    --undefined
                end case;
                    
            
            else                --CARRY
            
                case S is                   
                    when "0000" =>
                        DAPH_ALU_H <= AMX + '1';        --F=A+1
                    when "0011" =>
                        DAPH_ALU_H <= (others => '0');   --F=0 
                    when "0110" =>
                        DAPH_ALU_H <= AMX - BMX;        --F= A-B 
                    when "0111" =>
                        DAPH_ALU_H <= AMX AND NOT BMX;      --F=A!B
                    when "1001" =>
                        DAPH_ALU_H <= AMX + BMX + '1';  --F=A+B+1
                    when "1010" =>
                        DAPH_ALU_H <= (AMX + NOT BMX) + (AMX AND BMX) + '1'; --F=A!B + AB + 1
                    when "1011" =>
                        DAPH_ALU_H <= AMX AND BMX;      --F=AB
                    when "1100" =>
                        DAPH_ALU_H <= AMX + AMX + '1';  --F=A+A+1
                    when "1110" =>
                        DAPH_ALU_H <= (AMX AND NOT BMX) + AMX + '1'; --F=(A+!B)+A+1
                    when "1111" =>
                        DAPH_ALU_H <= AMX;               --F=A
                    when others =>
                        DAPH_ALU_H <= (others => 'X');    --undefined
                end case;
            
            end if;
            
        end if;
       
         
    end process;
    
    --GENERATE FUNCTION SIGNAL
    F <= DAPH_ALU_H(15 downto 0);
    --GENERATE LOW BYTE COMPARATOR SIGNAL
    A_B_L <= '1' when (AMX(7 downto 0) = BMX(7 downto 0)) else
             '0';
    --GENERATE FULL COMPARATOR SIGNAL
    A_B <= '1' when (AMX = BMX) else
           '0';              
    --GENERATE CARRY SIGNAL
    COUT <= CARRY_TEMP(16);

end Behavioral;
